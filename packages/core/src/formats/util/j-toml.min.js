/*!@preserve@license
 * 模块名称：j-toml
 * 模块功能：龙腾道为汤小明语写的实现。从属于“简计划”。
   　　　　　An implementation of TOML written by LongTengDao. Belong to "Plan J".
 * 模块版本：1.36.0
 * 许可条款：LGPL-3.0
 * 所属作者：龙腾道 <LongTengDao@LongTengDao.com> (www.LongTengDao.com)
 * 问题反馈：https://GitHub.com/LongTengDao/j-toml/issues
 * 项目主页：https://GitHub.com/LongTengDao/j-toml/
 */
(function (e, t) {
  'object' == typeof exports && 'undefined' != typeof module
    ? (module.exports = t())
    : 'function' == typeof define && define.amd
    ? define(t)
    : ((e = 'undefined' != typeof globalThis ? globalThis : e || self).TOML = t());
})(this, function () {
  'use strict';
  const e = SyntaxError,
    t = RangeError,
    n = TypeError,
    i = { if: Error }.if,
    r = void 0,
    s = 'undefined' == typeof BigInt ? r : BigInt,
    a = RegExp,
    l = WeakMap,
    o = WeakMap.prototype.get,
    c = WeakMap.prototype.set,
    u = Object.create,
    f = Number.isSafeInteger,
    h = Object.getOwnPropertyNames,
    d = Object.freeze,
    p = Object.prototype.isPrototypeOf,
    g = Object.seal ? Object.preventExtensions(Object.create(null)) : null,
    b = Function.prototype.bind,
    y = RegExp.prototype.test,
    w = RegExp.prototype.exec,
    m = Reflect.apply,
    x = Proxy,
    T = 'undefined' == typeof Symbol ? r : Symbol.toStringTag,
    v = Object.defineProperty,
    O = Object.assign,
    $ = Object,
    F = Math.floor,
    I = Array.isArray,
    k = 1 / 0,
    S = String.fromCharCode,
    M = Array,
    L = Object.prototype.hasOwnProperty,
    A = Object.prototype.propertyIsEnumerable,
    B = Function.prototype.apply;
  var U = A.call.bind(A),
    D =
      $.hasOwn ||
      (function () {
        return L.bind
          ? L.call.bind(L)
          : function (e, t) {
              return L.call(e, t);
            };
      })(),
    j = $.create;
  function C(e) {
    var t = j(g);
    return (
      D(e, 'value') && (t.value = e.value),
      D(e, 'writable') && (t.writable = e.writable),
      D(e, 'get') && (t.get = e.get),
      D(e, 'set') && (t.set = e.set),
      D(e, 'enumerable') && (t.enumerable = e.enumerable),
      D(e, 'configurable') && (t.configurable = e.configurable),
      t
    );
  }
  const _ = function (e, t) {
    if ((t || 'function' == typeof e || ((t = e), (e = u(g))), O)) O(e, t);
    else for (var n in t) D(t, n) && (e[n] = t[n]);
    if (((e.default = e), 'function' == typeof e)) e.prototype && d(e.prototype);
    else if (T) {
      var i = u(g);
      (i.value = 'Module'), v(e, T, i);
    }
    return d(e);
  };
  var N = b
      ? b.bind(y)
      : function (e) {
          return function (t) {
            return y.call(e, t);
          };
        },
    E = b
      ? b.bind(w)
      : function (e) {
          return function (t) {
            return w.call(e, t);
          };
        };
  function P(e) {
    var t = (e.test = N(e)),
      n = (e.exec = E(e)),
      i = (t.source = n.source = e.source);
    return (
      (t.unicode = n.unicode = e.unicode),
      (t.ignoreCase = n.ignoreCase = e.ignoreCase),
      (t.multiline = n.multiline = i.indexOf('^') < 0 && i.indexOf('$') < 0 ? null : e.multiline),
      (t.dotAll = n.dotAll = i.indexOf('.') < 0 ? null : e.dotAll),
      e
    );
  }
  function K(e) {
    return P(e);
  }
  var W = /[\n\t]+/g,
    R = /\\./g;
  function Z(e) {
    return '\\`' === e ? '`' : e;
  }
  var q = ''.includes
    ? function (e, t) {
        return e.includes(t);
      }
    : function (e, t) {
        return e.indexOf(t) > -1;
      };
  function H(t) {
    for (
      var i = this.U,
        r = this.I,
        s = this.M,
        l = this.S,
        o = t.raw,
        c = o[0].replace(W, ''),
        u = 1,
        f = arguments.length;
      u !== f;

    ) {
      var h = arguments[u];
      if ('string' == typeof h) c += h;
      else {
        var d = h.source;
        if ('string' != typeof d) throw n('source');
        if (h.unicode === i) throw e('unicode');
        if (h.ignoreCase === r) throw e('ignoreCase');
        if (h.multiline === s && (q(d, '^') || q(d, '$'))) throw e('multiline');
        if (h.dotAll === l && q(d, '.')) throw e('dotAll');
        c += d;
      }
      c += o[u++].replace(W, '');
    }
    var p = a(i ? (c = c.replace(R, Z)) : c, this.flags),
      g = (p.test = N(p)),
      b = (p.exec = E(p));
    return (
      (g.source = b.source = c),
      (g.unicode = b.unicode = !i),
      (g.ignoreCase = b.ignoreCase = !r),
      (g.multiline = b.multiline = q(c, '^') || q(c, '$') ? !s : null),
      (g.dotAll = b.dotAll = q(c, '.') ? !l : null),
      p
    );
  }
  var z = b && b.bind(H);
  function Y(e) {
    return { U: !q(e, 'u'), I: !q(e, 'i'), M: !q(e, 'm'), S: !q(e, 's'), flags: e };
  }
  var J = Y(''),
    V = x
      ? new x(H, {
          apply: function (e, t, n) {
            return m(e, J, n);
          },
          get: function (e, t) {
            return z(Y(t));
          },
          defineProperty: function () {
            return !1;
          },
          preventExtensions: function () {
            return !1;
          },
        })
      : (function () {
          H.apply = H.apply;
          for (
            var e = function () {
                return H.apply(J, arguments);
              },
              t = 63;
            t--;

          )
            !(function (t) {
              e[t.flags] = function () {
                return H.apply(t, arguments);
              };
            })(
              Y(
                (1 & t ? '' : 'd') +
                  (2 & t ? '' : 'g') +
                  (4 & t ? '' : 'i') +
                  (8 & t ? '' : 'm') +
                  (8 & t ? '' : 's') +
                  (16 & t ? '' : 'u') +
                  (32 & t ? '' : 'y'),
              ),
            );
          return d ? d(e) : e;
        })(),
    G =
      '$_' in a
        ? (function () {
            var e = /^/;
            return (
              (e.test = e.test),
              function (t) {
                return e.test(''), t;
              }
            );
          })()
        : function (e) {
            return e;
          },
    X = /^[$()*+\-.?[\\\]^{|]/,
    Q = /^[\uD800-\uDBFF][\uDC00-\uDFFF]/,
    ee = u(g);
  function te(e, t, n) {
    for (var i = u(g), r = t ? ne : ie, s = e.length, a = 0; a < s; ++a) r(i, e[a]);
    return re(i, !n);
  }
  function ne(e, t) {
    if (t) {
      var n = Q.test(t) ? t.slice(0, 2) : t.charAt(0);
      ne(e[n] || (e[n] = u(g)), t.slice(n.length));
    } else e[''] = ee;
  }
  function ie(e, t) {
    if (t) {
      var n = t.charAt(0);
      ie(e[n] || (e[n] = u(g)), t.slice(1));
    } else e[''] = ee;
  }
  function re(e, t) {
    var n = [],
      i = [],
      r = !0;
    for (var s in e)
      if (s) {
        var a = re(e[s], t);
        t && X.test(s) && (s = '\\' + s), a ? n.push(s + a) : i.push(s);
      } else r = !1;
    return (
      i.length && n.unshift(1 === i.length ? i[0] : '[' + i.join('') + ']'),
      0 === n.length
        ? ''
        : (1 === n.length && (i.length || r) ? n[0] : '(?:' + n.join('|') + ')') + (r ? '' : '?')
    );
  }
  const se = WeakSet,
    ae = WeakSet.prototype.has,
    le = WeakSet.prototype.add,
    oe = WeakSet.prototype.delete,
    ce = Object.keys,
    ue = Object.getOwnPropertySymbols,
    fe = (function () {
      var e =
        Object.assign ||
        function (e, t) {
          var n, i, r;
          for (n = ce(t), i = 0; i < n.length; ++i) e[(r = n[i])] = t[r];
          if (ue) for (n = ue(t), i = 0; i < n.length; ++i) U(t, (r = n[i])) && (e[r] = t[r]);
          return e;
        };
      function t(e) {
        return delete e.prototype.constructor, d(e.prototype), e;
      }
      function n(n) {
        return n === r ? this : 'function' == typeof n ? t(n) : e(j(g), n);
      }
      return delete n.name, (n.prototype = null), d(n), n;
    })(),
    he = Object.is,
    de = Object.defineProperties,
    pe = Object.fromEntries,
    ge = Reflect.construct,
    be = Reflect.defineProperty,
    ye = Reflect.deleteProperty,
    we = Reflect.ownKeys,
    me = () => {
      const e = new l();
      return (e.has = e.has), (e.get = e.get), (e.set = e.set), e;
    },
    xe = me(),
    Te = me(),
    ve = me(),
    Oe = O(u(g), {
      defineProperty: (e, t, n) => {
        if (D(e, t)) return be(e, t, O(u(g), n));
        if (be(e, t, O(u(g), n))) {
          const n = xe.get(e);
          return (n[n.length] = t), !0;
        }
        return !1;
      },
      deleteProperty: (e, t) => {
        if (ye(e, t)) {
          const n = xe.get(e),
            i = n.indexOf(t);
          return i < 0 || --n.copyWithin(i, i + 1).length, !0;
        }
        return !1;
      },
      ownKeys: e => xe.get(e),
      construct: (e, t, n) => Fe(ge(e, t, n)),
      apply: (e, t, n) => Fe(m(e, t, n)),
    }),
    $e = (e, t) => {
      xe.set(e, t);
      const n = new x(e, Oe);
      return Te.set(n, e), n;
    },
    Fe = e => {
      if (Te.has(e)) return e;
      let t = ve.get(e);
      return t || ((t = $e(e, O([], we(e)))), ve.set(e, t), t);
    },
    Ie = (function () {
      function e() {
        throw n("Super constructor Null cannot be invoked with 'new'");
      }
      function t() {
        throw n("Super constructor Null cannot be invoked without 'new'");
      }
      const i = e => (delete e.prototype.constructor, d(e.prototype), e);
      function r(n) {
        return new.target
          ? new.target === r
            ? e()
            : $e(this, [])
          : 'function' == typeof n
          ? i(n)
          : t();
      }
      return (r.prototype = null), v(r, 'name', O(u(g), { value: '', configurable: !1 })), d(r), r;
    })(),
    ke = WeakMap.prototype.has,
    Se = WeakMap.prototype.delete,
    Me = new l(),
    Le = new se(),
    Ae = Se.bind(Me),
    Be = oe.bind(Le),
    Ue = ke.bind(Me),
    De = o.bind(Me),
    je = c.bind(Me),
    Ce = e => (Ae(e), e),
    _e = ae.bind(Le),
    Ne = le.bind(Le),
    Ee = new se(),
    Pe = le.bind(Ee),
    Ke = ae.bind(Ee),
    We = new se(),
    Re = le.bind(We),
    Ze = oe.bind(We),
    qe = !0,
    He = !1,
    ze = new se(),
    Ye = le.bind(ze),
    Je = ae.bind(ze),
    Ve = fe(
      class extends fe {
        constructor(e, t) {
          return super(), Pe(this), e ? (t ? je(this, !0) : Ne(this)) : (t ? Ye : Re)(this), this;
        }
      },
    ),
    Ge = fe(
      class extends Ie {
        constructor(e, t) {
          return super(), Pe(this), e ? (t ? je(this, !0) : Ne(this)) : (t ? Ye : Re)(this), this;
        }
      },
    ),
    Xe = [];
  let Qe = '',
    et = Xe,
    tt = -1,
    nt = -1;
  const it = e => {
      throw e;
    },
    rt = /\r?\n/,
    st = (e, t) => {
      if ('string' != typeof t) throw n('TOML.parse({ path })');
      (Qe = t), (et = e.split(rt)), (tt = et.length - 1), (nt = -1);
    };
  class at {
    lineIndex = nt;
    type;
    restColumn;
    constructor(e, t) {
      return (this.type = e), (this.restColumn = t), this;
    }
    must() {
      return (
        nt === tt &&
          it(
            e(
              `${this.type} is not close until the end of the file` +
                lt(
                  ', which started from ',
                  this.lineIndex,
                  et[this.lineIndex].length - this.restColumn + 1,
                ),
            ),
          ),
        et[++nt]
      );
    }
    nowrap(e) {
      throw it(
        i(
          `TOML.parse(${
            e ? `${e}multilineStringJoiner` : ',{ joiner }'
          }) must be passed, while the source including multi-line string` +
            lt(
              ', which started from ',
              this.lineIndex,
              et[this.lineIndex].length - this.restColumn + 1,
            ),
        ),
      );
    }
  }
  const lt = (e, t = nt, n = 0) =>
      et === Xe ? '' : Qe ? `\n    at (${Qe}:${t + 1}:${n})` : `${e}line ${t + 1}: ${et[t]}`,
    ot = () => {
      (Qe = ''), (et = Xe);
    },
    ct = /[ \t]/,
    ut = V`
	^${ct}+`.valueOf(),
    { exec: ft } = V.s`
	^
	(
		(?:\d\d\d\d-\d\d-\d\d \d)?
		[\w\-+.:]+
	)
	${ct}*
	(.*)
	$`.valueOf(),
    { exec: ht } = V.s`
	^
	'([^']*)'
	${ct}*
	(.*)`.valueOf(),
    { exec: dt } = V.s`
	^
	(.*?)
	'''('{0,2})
	${ct}*
	(.*)`.valueOf(),
    { exec: pt } = V.s`
	^
	(.*?)
	'''()
	${ct}*
	(.*)`.valueOf();
  let gt = pt;
  const bt = V.s`
	^
	.
	${ct}*`.valueOf(),
    yt = /[^\x00-\x1F"#'()<>[\\\]`{}\x7F]+/,
    { exec: wt } = V.s`
	^
	${ct}*
	=
	${ct}*
	(?:
		<(${yt})>
		${ct}*
	)?
	(.*)
	$`.valueOf(),
    { exec: mt } = V.s`
	^
	<(${yt})>
	${ct}*
	(.*)
	$`.valueOf(),
    { exec: xt } = V.s`
	^
	<(${yt})>
	${ct}*
	(.*)
	$`.valueOf(),
    Tt = K(/[^\\"]+|\\.?|"(?!"")"?/sy),
    vt = e => {
      let t = 0;
      for (; Tt.test(e); ) t = Tt.lastIndex;
      return t;
    },
    Ot =
      /[^\\\x00-\x08\x0B-\x1F\x7F]+|\\(?:[btnfr"\\]|[\t ]*\n[\t\n ]*|u[\dA-Fa-f]{4}|U[\dA-Fa-f]{8})/g,
    $t =
      /[^\\\x00-\x09\x0B-\x1F\x7F]+|\\(?:[btnfr"\\]|[\t ]*\n[\t\n ]*|u[\dA-Fa-f]{4}|U[\dA-Fa-f]{8})/g,
    Ft =
      /[^\\\x00-\x09\x0B-\x1F]+|\\(?:[btnfr"\\]|[\t ]*\n[\t\n ]*|u[\dA-Fa-f]{4}|U[\dA-Fa-f]{8})/g,
    It =
      /[^\\\x00-\x09\x0B-\x1F]+|\\(?:[btnfr"\\/]|[\t ]*\n[\t\n ]*|u[\dA-Fa-f]{4}|U[\dA-Fa-f]{8})/g;
  let kt = Ot;
  const St = e => !e.replace(kt, ''),
    Mt = K(/[^\\"\x00-\x08\x0B-\x1F\x7F]+|\\(?:[btnfr"\\]|u[\dA-Fa-f]{4}|U[\dA-Fa-f]{8})/y),
    Lt = K(/[^\\"\x00-\x08\x0B-\x1F\x7F]+|\\(?:[btnfr"\\]|u[\dA-Fa-f]{4}|U[\dA-Fa-f]{8})/y),
    At = K(/[^\\"\x00-\x08\x0B-\x1F]+|\\(?:[btnfr"\\]|u[\dA-Fa-f]{4}|U[\dA-Fa-f]{8})/y),
    Bt = K(/[^\\"\x00-\x08\x0B-\x1F]+|\\(?:[btnfr"\\/]|u[\dA-Fa-f]{4}|U[\dA-Fa-f]{8})/y);
  let Ut = Bt;
  const Dt = t => {
      let n = (Ut.lastIndex = 1);
      for (; Ut.test(t); ) n = Ut.lastIndex;
      return (n !== t.length && '"' === t[n]) || it(e('Bad basic string' + lt(' at '))), n;
    },
    { test: jt } = K(/^[ \t]*\./),
    Ct = /^[ \t]*\.[ \t]*/,
    { exec: _t } = K(/^[\w-]+/),
    { exec: Nt } = K(/^[^ \t#=[\]'".]+(?:[ \t]+[^ \t#=[\]'".]+)*/);
  let Et = Nt;
  const { exec: Pt } = K(/^'[^'\x00-\x08\x0B-\x1F\x7F]*'/),
    { exec: Kt } = K(/^'[^'\x00-\x08\x0B-\x1F]*'/);
  let Wt = Kt,
    Rt = !0;
  const Zt = (t, n) => {
      const i = '[' === t[1];
      i
        ? (Rt || it(e('Array of Tables is not allowed before TOML v0.2' + lt(', which at '))),
          (t = t.slice(2)))
        : (t = t.slice(1)),
        (t = t.replace(ut, ''));
      const { leadingKeys: r, finalKey: s } = ({ lineRest: t } = n(t));
      let a;
      return (
        ((t = t.replace(ut, '')) && ']' === t[0]) ||
          it(e('Table header is not closed' + lt(', which is found at '))),
        (t.length > 1 ? (']' === t[1]) === i : !i) ||
          it(e('Square brackets of Table definition statement not match' + lt(' at '))),
        (t = t.slice(i ? 2 : 1).replace(ut, '')) && '<' === t[0]
          ? ({ 1: a, 2: t } = xt(t) || it(e('Bad tag' + lt(' at '))))
          : (a = ''),
        { leadingKeys: r, finalKey: s, asArrayItem: i, tag: a, lineRest: t }
      );
    },
    { test: qt } = K(/[\x00-\x08\x0B-\x1F\x7F]/),
    { test: Ht } = K(/[\x00-\x08\x0B-\x1F]/);
  let zt = qt;
  const Yt = V`
	(?:
		0
		(?:
			b[01][_01]*
		|
			o[0-7][_0-7]*
		|
			x[\dA-Fa-f][_\dA-Fa-f]*
		|
			(?:\.\d[_\d]*)?(?:[Ee]-?\d[_\d]*)?
		)
	|
		[1-9][_\d]*
		(?:\.\d[_\d]*)?(?:[Ee]-?\d[_\d]*)?
	|
		inf
	|
		nan
	)
`.valueOf(),
    { test: Jt } = V`
	^(?:
		-?${Yt}
		(?:-${Yt})*
	|
		true
	|
		false
	)$
`.valueOf(),
    { test: Vt } = V`_(?![\dA-Fa-f])`.valueOf(),
    Gt = e => Jt(e) && !Vt(e);
  let Xt = !0,
    Qt = '',
    en = null,
    tn = !0,
    nn = 0,
    rn = 0;
  const sn = { test: () => !0 },
    an = class extends a {
      constructor(e) {
        super(`^${te(e)}$`);
        let t = -1;
        for (let n = e.length; n; ) {
          const { length: i } = e[--n];
          i > t && (t = i);
        }
        return (this.lastIndex = t + 1), this;
      }
      test(e) {
        return e.length < this.lastIndex && super.test(e);
      }
    },
    ln = p.bind(d(an.prototype));
  let on,
    cn,
    un,
    fn,
    hn,
    dn,
    pn,
    gn,
    bn,
    yn,
    wn,
    mn,
    xn,
    Tn = sn;
  const vn = new l(),
    On = o.bind(vn),
    $n = c.bind(vn),
    Fn = () => {
      const e = t => {
        const i = On(t);
        return i ? i === e || it(n('Types in Array must be same' + lt('. Check '))) : $n(t, e), t;
      };
      return e;
    },
    In = {
      asNulls: Fn(),
      asStrings: Fn(),
      asTables: Fn(),
      asArrays: Fn(),
      asBooleans: Fn(),
      asFloats: Fn(),
      asIntegers: Fn(),
      asOffsetDateTimes: Fn(),
      asLocalDateTimes: Fn(),
      asLocalDates: Fn(),
      asLocalTimes: Fn(),
    },
    kn = e => e;
  let Sn,
    Mn,
    Ln,
    An,
    Bn,
    Un,
    Dn,
    jn,
    Cn,
    _n,
    Nn,
    En = null,
    Pn = null;
  const Kn = (e, t, n, i) => {
      const r = u(g);
      (r._linked = Pn),
        (r.tag = e),
        n && ((r.table = n), (r.key = i)),
        t && ((r.array = t), (r.index = t.length)),
        (Pn = r);
    },
    Wn = () => {
      throw it(e('xOptions.tag is not enabled, but found tag syntax' + lt(' at ')));
    };
  let Rn = Wn;
  const Zn = ArrayBuffer.isView,
    qn = (function () {
      if ('function' == typeof ArrayBuffer) {
        var e = B.bind(Object.getOwnPropertyDescriptor(ArrayBuffer.prototype, 'byteLength').get);
        return function (t) {
          try {
            e(t);
          } catch (n) {
            return !1;
          }
          return !0;
        };
      }
      return function () {
        return !1;
      };
    })(),
    Hn = TextDecoder,
    zn = Symbol,
    Yn = zn('previous'),
    Jn = e => {
      let t = e,
        n = t.next();
      if (!n.done)
        for (n.value[Yn] = t, n = (t = n.value).next(); ; )
          if (n.done) {
            if (t === e) break;
            (t = t[Yn]), (n = t.next(n.value));
          } else (n.value[Yn] = t), (n = (t = n.value).next());
      return n.value;
    },
    Vn = zn('_literal'),
    Gn = (e, t) => {
      const n = $(t);
      return (n[Vn] = e), n;
    },
    Xn = new se(),
    Qn = le.bind(Xn),
    ei = ae.bind(Xn),
    ti = new se(),
    ni = le.bind(ti),
    ii = ae.bind(ti),
    ri = e => {
      const t = [];
      return Qn(t), e && ni(t), t;
    },
    si = Date,
    ai = Date.parse,
    li = Object.preventExtensions,
    oi = Object.getOwnPropertyDescriptors,
    ci = function (e, t) {
      for (var n = u(g), i = ce(t), r = i.length, s = 0; s < r; ++s) {
        var a = i[s];
        n[a] = C(t[a]);
      }
      if (ue) {
        var l = ue(t);
        for (r = l.length, s = 0; s < r; ++s) {
          var o = l[s];
          U(t, o) && (n[o] = C(t[o]));
        }
      }
      return de(e, n);
    },
    ui = e => (d(d(e).prototype), e),
    fi = /(?:0[1-9]|[12]\d|30)/,
    hi = /(?:0[1-9]|[12]\d|3[01])/,
    di = /(?:[01]\d|2[0-3])/,
    pi = /[0-5]\d/,
    gi = V`
	\d\d\d\d-
	(?:
		0
		(?:
			[13578]-${hi}
			|
			[469]-${fi}
			|
			2-${/(?:0[1-9]|1\d|2\d)/}
		)
		|
		1
		(?:
			[02]-${hi}
			|
			1-${fi}
		)
	)
`.valueOf(),
    bi = V`
	${di}:${pi}:${pi}
`.valueOf(),
    { exec: yi } = K(/(([+-])\d\d):(\d\d)$/),
    { exec: wi } = V`
	^
	${gi}
	[Tt ]
	${bi}
	(?:\.\d{1,3}(\d*?)0*)?
	(?:[Zz]|[+-]${di}:${pi})
	$`.valueOf(),
    { exec: mi } = V`
	^
	${gi}
	[Tt ]
	${bi}
	()
	[Zz]
	$`.valueOf(),
    { test: xi } = V`
	^
	${gi}
	[Tt ]
	${bi}
	(?:\.\d+)?
	$`.valueOf(),
    { test: Ti } = V`
	^
	${gi}
	$`.valueOf(),
    { test: vi } = V`
	^
	${bi}
	(?:\.\d+)?
	$`.valueOf(),
    Oi = /[ t]/,
    $i = /[-T:.]/g,
    Fi = /\.?0+$/,
    Ii = /\.(\d*?)0+$/,
    ki = (e, t) => t,
    Si = (() => {
      const e = function () {
          return this;
        },
        t = fe(null);
      {
        const e = fe(null);
        for (const n of we(si.prototype)) 'constructor' === n || 'toJSON' === n || (t[n] = e);
      }
      return (
        (t[zn.toStringTag] = fe({ value: 'Date' })), (e.prototype = li(u(si.prototype, t))), d(e)
      );
    })(),
    Mi = e => e.replace(Ii, ki).replace($i, ''),
    Li = /./gs,
    Ai = e => '          '[e],
    Bi = e => {
      if (e.startsWith('02-29', 5)) {
        const t = +e.slice(0, 4);
        return !(3 & t || (!(t % 100) && (t % 400 || !(t % 3200))));
      }
      return !0;
    },
    { test: Ui } = V.s`^.....(?:06.30|12.31).23:59:59`.valueOf(),
    Di = ci(new si(0), oi(si.prototype)),
    ji = zn('OffsetDateTime_ISOString'),
    Ci = zn('OffsetDateTime_value'),
    _i = (e, t = 0) => (Di.setTime(+e[Ci] + t), Di),
    Ni = ui(
      class extends Si {
        [ji];
        [Ci];
        valueOf() {
          return this[Ci];
        }
        toISOString() {
          return this[ji];
        }
        constructor(t) {
          Bi(t) || it(e(`Invalid Offset Date-Time ${t}` + lt(' at ')));
          const n = t.startsWith('60', 17);
          let i = n ? t.slice(0, 17) + '59' + t.slice(19) : t;
          const { 1: r = '' } =
              (cn ? mi(i) : wi(i)) || it(e(`Invalid Offset Date-Time ${t}` + lt(' at '))),
            s = ai((i = i.replace(Oi, 'T').replace('z', 'Z')));
          return (
            n &&
              (Di.setTime(s),
              Ui(Di.toISOString()) || it(e(`Invalid Offset Date-Time ${t}` + lt(' at ')))),
            super(),
            (this[ji] = i),
            (this[Ci] = ((e, t) =>
              e < 0
                ? ('' + (e + 6216730554e4)).replace(Li, Ai).padStart(14, ' ') +
                  t.replace(Li, Ai) +
                  e
                : t
                ? (e + '.').padStart(16, '0') + t
                : ('' + e).padStart(15, '0'))(s, r)),
            this
          );
        }
        getUTCFullYear() {
          return _i(this).getUTCFullYear();
        }
        getUTCMonth() {
          return _i(this).getUTCMonth();
        }
        getUTCDate() {
          return _i(this).getUTCDate();
        }
        getUTCHours() {
          return _i(this).getUTCHours();
        }
        getUTCMinutes() {
          return _i(this).getUTCMinutes();
        }
        getUTCSeconds() {
          return _i(this).getUTCSeconds();
        }
        getUTCMilliseconds() {
          return _i(this).getUTCMilliseconds();
        }
        getUTCDay() {
          return _i(this).getUTCDay();
        }
        getTimezoneOffset() {
          const e = yi(this[ji]);
          return e ? 60 * +e[1] + +(e[2] + e[3]) : 0;
        }
        getTime() {
          return F(+this[Ci]);
        }
      },
    ),
    Ei = zn('LocalDateTime_ISOString'),
    Pi = zn('LocalDateTime_value'),
    Ki = (e, t, n) => +e[Ei].slice(t, n),
    Wi = (e, n, i, r) => {
      const s = '' + r,
        a = i - n;
      if (s.length > a) throw t();
      e[Pi] = Mi((e[Ei] = e[Ei].slice(0, n) + s.padStart(a, '0') + e[Ei].slice(i)));
    },
    Ri = ui(
      class extends Si {
        [Ei];
        [Pi];
        valueOf() {
          return this[Pi];
        }
        toISOString() {
          return this[Ei];
        }
        constructor(t) {
          return (
            (xi(t) && Bi(t)) || it(e(`Invalid Local Date-Time ${t}` + lt(' at '))),
            super(),
            (this[Pi] = Mi((this[Ei] = t.replace(Oi, 'T')))),
            this
          );
        }
        getFullYear() {
          return Ki(this, 0, 4);
        }
        setFullYear(e) {
          Wi(this, 0, 4, e);
        }
        getMonth() {
          return Ki(this, 5, 7) - 1;
        }
        setMonth(e) {
          Wi(this, 5, 7, e + 1);
        }
        getDate() {
          return Ki(this, 8, 10);
        }
        setDate(e) {
          Wi(this, 8, 10, e);
        }
        getHours() {
          return Ki(this, 11, 13);
        }
        setHours(e) {
          Wi(this, 11, 13, e);
        }
        getMinutes() {
          return Ki(this, 14, 16);
        }
        setMinutes(e) {
          Wi(this, 14, 16, e);
        }
        getSeconds() {
          return Ki(this, 17, 19);
        }
        setSeconds(e) {
          Wi(this, 17, 19, e);
        }
        getMilliseconds() {
          return +this[Pi].slice(14, 17).padEnd(3, '0');
        }
        setMilliseconds(e) {
          this[Pi] = Mi(
            (this[Ei] =
              this[Ei].slice(0, 19) + (e ? ('.' + ('' + e).padStart(3, '0')).replace(Fi, '') : '')),
          );
        }
      },
    ),
    Zi = zn('LocalDate_ISOString'),
    qi = zn('LocalDate_value'),
    Hi = (e, t, n) => +e[Zi].slice(t, n),
    zi = (e, n, i, r) => {
      const s = '' + r,
        a = i - n;
      if (s.length > a) throw t();
      e[qi] = Mi((e[Zi] = e[Zi].slice(0, n) + s.padStart(a, '0') + e[Zi].slice(i)));
    },
    Yi = ui(
      class extends Si {
        [Zi];
        [qi];
        valueOf() {
          return this[qi];
        }
        toISOString() {
          return this[Zi];
        }
        constructor(t) {
          return (
            (Ti(t) && Bi(t)) || it(e(`Invalid Local Date ${t}` + lt(' at '))),
            super(),
            (this[qi] = Mi((this[Zi] = t))),
            this
          );
        }
        getFullYear() {
          return Hi(this, 0, 4);
        }
        setFullYear(e) {
          zi(this, 0, 4, e);
        }
        getMonth() {
          return Hi(this, 5, 7) - 1;
        }
        setMonth(e) {
          zi(this, 5, 7, e + 1);
        }
        getDate() {
          return Hi(this, 8, 10);
        }
        setDate(e) {
          zi(this, 8, 10, e);
        }
      },
    ),
    Ji = zn('LocalTime_ISOString'),
    Vi = zn('LocalTime_value'),
    Gi = (e, t, n) => +e[Ji].slice(t, n),
    Xi = (e, n, i, r) => {
      const s = '' + r;
      if (s.length > i - n) throw t();
      e[Vi] = Mi((e[Ji] = e[Ji].slice(0, n) + s.padStart(2, '0') + e[Ji].slice(i)));
    },
    Qi = ui(
      class extends Si {
        [Ji];
        [Vi];
        valueOf() {
          return this[Vi];
        }
        toISOString() {
          return this[Ji];
        }
        constructor(t) {
          return (
            vi(t) || it(e(`Invalid Local Time ${t}` + lt(' at '))),
            super(),
            (this[Vi] = Mi((this[Ji] = t))),
            this
          );
        }
        getHours() {
          return Gi(this, 0, 2);
        }
        setHours(e) {
          Xi(this, 0, 2, e);
        }
        getMinutes() {
          return Gi(this, 3, 5);
        }
        setMinutes(e) {
          Xi(this, 3, 5, e);
        }
        getSeconds() {
          return Gi(this, 6, 8);
        }
        setSeconds(e) {
          Xi(this, 6, 8, e);
        }
        getMilliseconds() {
          return +this[Vi].slice(6, 9).padEnd(3, '0');
        }
        setMilliseconds(e) {
          this[Vi] = Mi(
            (this[Ji] =
              this[Ji].slice(0, 8) + (e ? ('.' + ('' + e).padStart(3, '0')).replace(Fi, '') : '')),
          );
        }
      },
    ),
    er = parseInt,
    tr = String.fromCodePoint,
    nr = /[^\\]+|\\(?:[\\"btnfr/]|u.{4}|U.{8})/gs,
    ir = /[^\n\\]+|\n|\\(?:[\t ]*\n[\t\n ]*|[\\"btnfr/]|u.{4}|U.{8})/gs,
    rr = e => {
      if (!e) return '';
      const n = e.match(nr),
        { length: i } = n;
      let r = 0;
      do {
        const e = n[r];
        if ('\\' === e[0])
          switch (e[1]) {
            case '\\':
              n[r] = '\\';
              break;
            case '"':
              n[r] = '"';
              break;
            case 'b':
              n[r] = '\b';
              break;
            case 't':
              n[r] = '\t';
              break;
            case 'n':
              n[r] = '\n';
              break;
            case 'f':
              n[r] = '\f';
              break;
            case 'r':
              n[r] = '\r';
              break;
            case 'u':
              const i = er(e.slice(2), 16);
              Xt && 55295 < i && i < 57344 && it(t(`Invalid Unicode Scalar ${e}` + lt(' at '))),
                (n[r] = S(i));
              break;
            case 'U':
              const s = er(e.slice(2), 16);
              ((Xt && 55295 < s && s < 57344) || 1114111 < s) &&
                it(t(`Invalid Unicode Scalar ${e}` + lt(' at '))),
                (n[r] = tr(s));
              break;
            case '/':
              n[r] = '/';
          }
      } while (++r !== i);
      return n.join('');
    },
    sr = (e, n, i) => {
      if (!e) return '';
      const r = e.match(ir),
        { length: s } = r;
      let a = 0;
      do {
        const e = r[a];
        if ('\n' === e) ++i, (r[a] = n);
        else if ('\\' === e[0])
          switch (e[1]) {
            case '\n':
            case ' ':
            case '\t':
              for (let t = 0; (t = e.indexOf('\n', t) + 1); ) ++i;
              r[a] = '';
              break;
            case '\\':
              r[a] = '\\';
              break;
            case '"':
              r[a] = '"';
              break;
            case 'b':
              r[a] = '\b';
              break;
            case 't':
              r[a] = '\t';
              break;
            case 'n':
              r[a] = '\n';
              break;
            case 'f':
              r[a] = '\f';
              break;
            case 'r':
              r[a] = '\r';
              break;
            case 'u':
              const n = er(e.slice(2), 16);
              Xt &&
                55295 < n &&
                n < 57344 &&
                it(t(`Invalid Unicode Scalar ${e}` + lt(' at ', nt + i))),
                (r[a] = S(n));
              break;
            case 'U':
              const s = er(e.slice(2), 16);
              ((Xt && 55295 < s && s < 57344) || 1114111 < s) &&
                it(t(`Invalid Unicode Scalar ${e}` + lt(' at ', nt + i))),
                (r[a] = tr(s));
              break;
            case '/':
              r[a] = '/';
          }
      } while (++a !== s);
      return r.join('');
    },
    ar = /[-+]?(?:0|[1-9][_\d]*)/,
    { test: lr } = V`_(?!\d)`.valueOf(),
    { test: or } = V`^${ar}$`.valueOf(),
    { test: cr } = K(/^0(?:x[\dA-Fa-f][_\dA-Fa-f]*|o[0-7][_0-7]*|b[01][_01]*)$/),
    { test: ur } = V`_(?![\dA-Fa-f])`.valueOf(),
    fr = /_/g,
    hr = /_|^[-+]/g,
    dr = e => (or(e) || cr(e)) && !ur(e),
    pr = s && -s('0x8000000000000000'),
    gr = s && s('0x7FFFFFFFFFFFFFFF'),
    br = n => {
      if (!0 === tn)
        return (n => {
          dr(n) || it(e(`Invalid Integer ${n}` + lt(' at ')));
          const i = '-' === n[0] ? -s(n.replace(hr, '')) : s(n.replace(hr, ''));
          return (
            bn ||
              (pr <= i && i <= gr) ||
              it(
                t(
                  `Integer expect 64 bit range (-9,223,372,036,854,775,808 to 9,223,372,036,854,775,807), not includes ${n}` +
                    lt(' meet at '),
                ),
              ),
            i
          );
        })(n);
      if (!1 === tn)
        return (n => {
          dr(n) || it(e(`Invalid Integer ${n}` + lt(' at ')));
          const i = er(n.replace(fr, ''));
          return (
            f(i) ||
              it(
                t(
                  `Integer did not use BitInt must fit Number.isSafeInteger, not includes ${n}` +
                    lt(' meet at '),
                ),
              ),
            i
          );
        })(n);
      dr(n) || it(e(`Invalid Integer ${n}` + lt(' at ')));
      const i = er(n.replace(fr, ''));
      if (nn <= i && i <= rn) return i;
      const r = '-' === n[0] ? -s(n.replace(hr, '')) : s(n.replace(hr, ''));
      return (
        bn ||
          (pr <= r && r <= gr) ||
          it(
            t(
              `Integer expect 64 bit range (-9,223,372,036,854,775,808 to 9,223,372,036,854,775,807), not includes ${n}` +
                lt(' meet at '),
            ),
          ),
        r
      );
    },
    yr = isFinite,
    { test: wr } = V`
	^
	${ar}
	(?:
		\.\d[_\d]*
		(?:[eE][-+]?\d[_\d]*)?
	|
		[eE][-+]?\d[_\d]*
	)
	$`.valueOf(),
    mr = /_/g,
    { test: xr } = K(/^[-+]?0(?:\.0+)?(?:[eE][-+]?0+)?$/),
    { exec: Tr } = K(/^[-0]?(\d*)(?:\.(\d+))?(?:e\+?(-?\d+))?$/),
    { exec: vr } = K(/^[-+]?0?(\d*)(?:\.(\d*?)0*)?(?:[eE]\+?(-?\d+))?$/),
    Or = n => {
      if (!wr(n) || lr(n)) {
        if (pn) {
          if ('inf' === n || '+inf' === n) return k;
          if ('-inf' === n) return -1 / 0;
          if ('nan' === n || '+nan' === n) return NaN;
          if ('-nan' === n) return NaN;
        }
        throw it(e(`Invalid Float ${n}` + lt(' at ')));
      }
      const i = n.replace(mr, ''),
        r = +i;
      if (dn) {
        yr(r) || it(t(`Float ${n} has been as big as inf` + lt(' at '))),
          r ||
            xr(i) ||
            it(t(`Float ${n} has been as little as ${'-' === n[0] ? '-' : ''}0` + lt(' at ')));
        const { 1: e, 2: s = '', 3: a = '' } = Tr(r),
          { 1: l, 2: o = '', 3: c = '' } = vr(i);
        (l + o === e + s && c - o.length == a - s.length) ||
          it(t(`Float ${n} has lost its exact and been ${r}` + lt(' at ')));
      }
      return r;
    },
    $r = (e, t) => {
      const { length: n } = t;
      let r = 0;
      for (; r < n; ) {
        const s = t[r++];
        if (!(s in e)) {
          for (e = e[s] = new gn(He); r < n; ) e = e[t[r++]] = new gn(He);
          return e;
        }
        if (Ke((e = e[s])))
          Ue(e) && it(i('Trying to define Table under Inline Table' + lt(' at ')));
        else {
          if (!ei(e)) throw it(i('Trying to define Table under non-Table value' + lt(' at ')));
          ii(e) && it(i('Trying to append value to Static Array' + lt(' at '))),
            (e = e[e.length - 1]);
        }
      }
      return e;
    },
    Fr = (e, t, n, r) => {
      let s;
      if (n) {
        let n;
        t in e
          ? (ei((n = e[t])) && !ii(n)) ||
            it(i('Trying to push Table to non-ArrayOfTables value' + lt(' at ')))
          : (n = e[t] = ri(!1)),
          r && Rn(r, n, e, t),
          (n[n.length] = s = new gn(qe));
      } else
        t in e
          ? ((s = e[t]),
            Je(s) &&
              it(
                i(
                  'A table defined implicitly via key/value pair can not be accessed to via []' +
                    lt(', which at '),
                ),
              ),
            (e => !!Ze(e) && (Ne(e), !0))(s) || it(i('Duplicate Table definition' + lt(' at '))))
          : (e[t] = s = new gn(qe)),
          r && Rn(r, null, e, t);
      return s;
    },
    Ir = (e, t) => {
      const { length: n } = t;
      let r = 0;
      for (; r < n; ) {
        const s = t[r++];
        if (!(s in e)) {
          for (e = e[s] = new gn(He, !0); r < n; ) e = e[t[r++]] = new gn(He, !0);
          return e;
        }
        Ke((e = e[s])) || it(i('Trying to assign property through non-Table value' + lt(' at '))),
          Ue(e) && it(i('Trying to assign property through static Inline Table' + lt(' at '))),
          Je(e) ||
            it(
              i(
                'A table defined implicitly via [] can not be accessed to via key/value pair' +
                  lt(', which at '),
              ),
            );
      }
      return e;
    },
    kr = t => (
      zt(t) &&
        it(
          e(
            'Control characters other than Tab are not permitted in a Literal String' +
              lt(', which was found at '),
          ),
        ),
      t
    ),
    Sr = (t, n, i) => {
      if (!i.startsWith("'''")) {
        const r = ht(i) || it(e('Bad literal string' + lt(' at '))),
          s = kr(r[1]);
        return (t[n] = on ? Gn(i.slice(0, s.length + 2), s) : s), r[2];
      }
      const r = gt(i.slice(3));
      if (r) {
        const e = kr(r[1]) + r[2];
        return (t[n] = on ? Gn(i.slice(0, e.length + 6), e) : e), r[3];
      }
      const s = new at('Multi-line Literal String', i.length),
        a = !(i = i.slice(3));
      if (a) {
        i = s.must();
        const e = gt(i);
        if (e) {
          const r = kr(e[1]) + e[2];
          return (t[n] = on ? Gn(["'''", i.slice(0, r.length + 3)], r) : r), e[3];
        }
      }
      null === en && s.nowrap(Qt);
      for (const e = [kr(i)]; ; ) {
        const r = s.must(),
          l = gt(r);
        if (l) {
          e[e.length] = kr(l[1]) + l[2];
          const r = e.join(en);
          return (
            on
              ? ((e[e.length - 1] += "'''"),
                a ? e.unshift("'''") : (e[0] = `'''${i}`),
                (t[n] = Gn(e, r)))
              : (t[n] = r),
            l[3]
          );
        }
        e[e.length] = kr(r);
      }
    },
    Mr = (t, n, i) => {
      if (!i.startsWith('"""')) {
        const e = Dt(i),
          r = rr(i.slice(1, e));
        return (t[n] = on ? Gn(i.slice(0, e + 1), r) : r), i.slice(e + 1).replace(ut, '');
      }
      let r = 3 + vt(i.slice(3));
      if (i.length !== r) {
        const s = i.slice(3, r);
        St(s) || it(e('Bad multi-line basic string' + lt(' at ')));
        const a =
          rr(s) + (i.startsWith('"', (r += 3)) ? (i.startsWith('"', ++r) ? (++r, '""') : '"') : '');
        return (t[n] = on ? Gn(i.slice(0, r), a) : a), i.slice(r).replace(ut, '');
      }
      const s = new at('Multi-line Basic String', r),
        a = (i = i.slice(3)) ? 0 : 1;
      if (a) {
        i = s.must();
        let r = vt(i);
        if (i.length !== r) {
          const s = i.slice(0, r);
          St(s) || it(e('Bad multi-line basic string' + lt(' at ')));
          const l =
            sr(s, en, a) +
            (i.startsWith('"', (r += 3)) ? (i.startsWith('"', ++r) ? (++r, '""') : '"') : '');
          return (t[n] = on ? Gn(['"""', i.slice(0, r)], l) : l), i.slice(r).replace(ut, '');
        }
      }
      null === en && s.nowrap(Qt),
        St(i + '\n') || it(e('Bad multi-line basic string' + lt(' at ')));
      for (const l = [i]; ; ) {
        const r = s.must();
        let o = vt(r);
        if (r.length !== o) {
          const s = r.slice(0, o);
          St(s) || it(e('Bad multi-line basic string' + lt(' at ')));
          const c =
            sr(l.join('\n') + '\n' + s, en, a) +
            (r.startsWith('"', (o += 3)) ? (r.startsWith('"', ++o) ? (++o, '""') : '"') : '');
          return (
            on
              ? (a ? l.unshift('"""') : (l[0] = `"""${i}`),
                (l[l.length] = `${s}"""`),
                (t[n] = Gn(l, c)))
              : (t[n] = c),
            r.slice(o).replace(ut, '')
          );
        }
        St(r + '\n') || it(e('Bad multi-line basic string' + lt(' at '))), (l[l.length] = r);
      }
    },
    Lr = fe(null),
    Ar = e => Lr[e] || (Lr[e] = zn(e)),
    Br = zn('this'),
    { test: Ur } = K(/\r?\n/g),
    Dr = (t, i) => {
      if (i in t) {
        const r = t[i];
        if ('string' != typeof r)
          throw n(
            `the value of comment must be a string, while "${
              null === r ? 'null' : typeof r
            }" type is found`,
          );
        if (Ur(r)) throw e('the value of comment must be a string and can not include newline');
        return ` #${r}`;
      }
      return '';
    },
    jr = (e, t) => (t in Lr ? Dr(e, Lr[t]) : ''),
    { test: Cr } = K(/(?:[Zz]|[+-]\d\d:\d\d)$/),
    { test: _r } = K(/^\[[\t ]*]/),
    Nr = t => {
      let n = t;
      const r = [];
      let s = -1;
      for (;;) {
        if ((n || it(e('Empty bare key' + lt(' at '))), '"' === n[0])) {
          const e = Dt(n);
          Tn.test((r[++s] = rr(n.slice(1, e)))) || it(i('Key not allowed' + lt(' at '))),
            (n = n.slice(e + 1));
        } else {
          const t = "'" === n[0],
            a = ((t ? Wt : Et)(n) ||
              it(e(`Bad ${t ? 'literal string' : 'bare'} key` + lt(' at '))))[0];
          (n = n.slice(a.length)),
            Tn.test((r[++s] = t ? a.slice(1, -1) : a)) || it(i('Key not allowed' + lt(' at ')));
        }
        if (!jt(n)) break;
        n = n.replace(Ct, '');
      }
      if (xn) {
        const i = t.slice(0, -n.length);
        (Gt(i) || (yn && 'null' === i)) &&
          it(e('Bad bare key disabled by xOptions.string' + lt(' at ')));
      }
      if (hn) {
        let t = s;
        do {
          r[t] || it(e('Empty key is not allowed before TOML v0.5' + lt(', which at ')));
        } while (t--);
      }
      const a = r[s];
      return (r.length = s), { leadingKeys: r, finalKey: a, lineRest: n };
    },
    Er = (t, n) => {
      if ('<' === n[0]) {
        const { 1: i } = ({ 2: n } = mt(n) || it(e('Bad tag ' + lt(' at '))));
        switch ((Rn(i, t, null), n && n[0])) {
          case ',':
          case ']':
          case '':
          case '#':
            return (t[t.length] = r), n;
        }
      }
      switch (n[0]) {
        case "'":
          return Sr(Mn(t), t.length, n);
        case '"':
          return Mr(Mn(t), t.length, n);
        case '{':
          return (
            un || it(e('Inline Table is not allowed before TOML v0.4' + lt(', which at '))),
            Kr(Ln(t), t.length, n)
          );
        case '[':
          return Pr(An(t), t.length, n);
      }
      const { 1: i } = ({ 2: n } = ft(n) || it(e('Bad atom value' + lt(' at '))));
      return (
        'true' === i
          ? (Bn(t)[t.length] = !0)
          : 'false' === i
          ? (Bn(t)[t.length] = !1)
          : yn && 'null' === i
          ? (Sn(t)[t.length] = null)
          : i.includes(':')
          ? i.includes('-')
            ? Cr(i)
              ? (jn(t)[t.length] = new Ni(i))
              : (fn || it(e('Local Date-Time is not allowed before TOML v0.5' + lt(', which at '))),
                (Cn(t)[t.length] = new Ri(i)))
            : (fn || it(e('Local Time is not allowed before TOML v0.5' + lt(', which at '))),
              (Nn(t)[t.length] = new Qi(i)))
          : i.indexOf('-') !== i.lastIndexOf('-') && '-' !== i[0]
          ? (fn || it(e('Local Date is not allowed before TOML v0.5' + lt(', which at '))),
            (_n(t)[t.length] = new Yi(i)))
          : i.includes('.') ||
            i.includes('n') ||
            ((i.includes('e') || i.includes('E')) && !i.startsWith('0x'))
          ? (Un(t)[t.length] = on ? Gn(i, Or(i)) : Or(i))
          : (Dn(t)[t.length] = on ? Gn(i, br(i)) : br(i)),
        n
      );
    },
    Pr = function* (t, n, i) {
      const r = (t[n] = ri(!0));
      if (_r(i)) return je(r, ']' === i[1] ? 0 : 3), i.slice(i.indexOf(']')).replace(bt, '');
      const s = new at('Static Array', i.length);
      let a = i.startsWith('[ ') || i.startsWith('[\t') ? 3 : 0;
      for (i = i.replace(bt, ''); !i || '#' === i[0]; ) (a = null), (i = s.must().replace(ut, ''));
      if (']' === i[0]) return null === a || je(r, a), i.replace(bt, '');
      for (;;) {
        const t = Er(r, i);
        for (i = 'string' == typeof t ? t : yield t; !i || '#' === i[0]; )
          (a = null), (i = s.must().replace(ut, ''));
        if (',' !== i[0]) {
          if (']' === i[0]) break;
          throw it(e('Unexpect character in static array item value' + lt(', which is found at ')));
        }
        for (i = i.replace(bt, ''); !i || '#' === i[0]; )
          (a = null), (i = s.must().replace(ut, ''));
        if (']' === i[0]) break;
      }
      return null === a || je(r, a), i.replace(bt, '');
    },
    Kr = function* (t, n, i) {
      const r = (t[n] = new gn(qe, !0));
      if (wn) {
        const e = new at('Inline Table', i.length);
        i = i.replace(bt, '');
        let t = !0;
        for (;;) {
          for (; !i || '#' === i[0]; ) (t = !1), (i = e.must().replace(ut, ''));
          if ('}' === i[0]) break;
          const n = Wr(r, i),
            s = Rr(n);
          if ((i = 'string' == typeof s ? s : yield s)) {
            if ('#' === i[0]) {
              mn && (n.table[Ar(n.finalKey)] = i.slice(1)), (t = !1);
              do {
                i = e.must().replace(ut, '');
              } while (!i || '#' === i[0]);
            }
          } else {
            t = !1;
            do {
              i = e.must().replace(ut, '');
            } while (!i || '#' === i[0]);
          }
          ',' === i[0] && (i = i.replace(bt, ''));
        }
        t || je(r, !1);
      } else if (
        '}' !==
        (i =
          i.replace(bt, '') ||
          it(
            e('Inline Table is intended to appear on a single line' + lt(', which broken at ')),
          ))[0]
      )
        for (;;) {
          '#' === i[0] &&
            it(e('Inline Table is intended to appear on a single line' + lt(', which broken at ')));
          const t = Rr(Wr(r, i));
          if (
            '}' ===
            (i =
              ('string' == typeof t ? t : yield t) ||
              it(
                e('Inline Table is intended to appear on a single line' + lt(', which broken at ')),
              ))[0]
          )
            break;
          ',' === i[0] &&
            '}' ===
              (i =
                i.replace(bt, '') ||
                it(
                  e(
                    'Inline Table is intended to appear on a single line' +
                      lt(', which broken at '),
                  ),
                ))[0] &&
            it(
              e(
                'The last property of an Inline Table can not have a trailing comma' +
                  lt(', which was found at '),
              ),
            );
        }
      return i.replace(bt, '');
    },
    Wr = (t, n) => {
      const {
        leadingKeys: i,
        finalKey: r,
        tag: s,
      } = ({ lineRest: n } = (({ leadingKeys: t, finalKey: n, lineRest: i }) => {
        const { 1: r = '' } = ({ 2: i } =
          wt(i) || it(e('Keys must equal something' + lt(', but missing at '))));
        return (
          r ||
            (i && '#' !== i[0]) ||
            it(e('Value can not be missing after euqal sign' + lt(', which is found at '))),
          { leadingKeys: t, finalKey: n, tag: r, lineRest: i }
        );
      })(Nr(n)));
      return { table: Ir(t, i), finalKey: r, tag: s, lineRest: n };
    },
    Rr = ({ finalKey: t, tag: n, lineRest: s, table: a }) => {
      if ((t in a && it(i('Duplicate property definition' + lt(' at '))), n))
        switch ((Rn(n, null, a, t), s && s[0])) {
          case ',':
          case '}':
          case '':
          case '#':
            return (a[t] = r), s;
        }
      switch (s && s[0]) {
        case "'":
          return Sr(a, t, s);
        case '"':
          return Mr(a, t, s);
        case '{':
          return (
            un || it(e('Inline Table is not allowed before TOML v0.4' + lt(', which at '))),
            Kr(a, t, s)
          );
        case '[':
          return Pr(a, t, s);
      }
      const { 1: l } = ({ 2: s } = ft(s) || it(e('Bad atom value' + lt(' at '))));
      return (
        'true' === l
          ? (a[t] = !0)
          : 'false' === l
          ? (a[t] = !1)
          : yn && 'null' === l
          ? (a[t] = null)
          : l.includes(':')
          ? l.includes('-')
            ? Cr(l)
              ? (a[t] = new Ni(l))
              : (fn || it(e('Local Date-Time is not allowed before TOML v0.5' + lt(', which at '))),
                (a[t] = new Ri(l)))
            : (fn || it(e('Local Time is not allowed before TOML v0.5' + lt(', which at '))),
              (a[t] = new Qi(l)))
          : l.indexOf('-') !== l.lastIndexOf('-') && '-' !== l[0]
          ? (fn || it(e('Local Date is not allowed before TOML v0.5' + lt(', which at '))),
            (a[t] = new Yi(l)))
          : (a[t] =
              l.includes('.') ||
              l.includes('n') ||
              ((l.includes('e') || l.includes('E')) && !l.startsWith('0x'))
                ? on
                  ? Gn(l, Or(l))
                  : Or(l)
                : on
                ? Gn(l, br(l))
                : br(l)),
        s
      );
    },
    Zr = () => {
      const t = new gn();
      let n = t;
      for (; nt !== tt; ) {
        const i = et[++nt].replace(ut, '');
        if (i)
          if ('[' === i[0]) {
            const { leadingKeys: r, finalKey: s, asArrayItem: a, tag: l, lineRest: o } = Zt(i, Nr),
              c = $r(t, r);
            o && ('#' === o[0] || it(e('Unexpect charachtor after table header' + lt(' at ')))),
              (n = Fr(c, s, a, l)),
              mn && o && (n[Br] = a ? o.slice(1) : (c[Ar(s)] = o.slice(1)));
          } else if ('#' === i[0])
            zt(i) &&
              it(
                e(
                  'Control characters other than Tab are not permitted in comments' +
                    lt(', which was found at '),
                ),
              );
          else {
            const t = Wr(n, i);
            let r = Rr(t);
            'string' == typeof r || (r = Jn(r)),
              r &&
                ('#' === r[0] || it(e('Unexpect charachtor after key/value pair' + lt(' at '))),
                mn && (t.table[Ar(t.finalKey)] = r.slice(1)));
          }
      }
      return t;
    },
    qr = Number.MAX_SAFE_INTEGER,
    Hr = Date.prototype,
    zr = String.prototype.valueOf,
    Yr = (function () {
      if (B.bind) {
        var e = B.bind(zr);
        return function (t) {
          try {
            e(t);
          } catch (n) {
            return !1;
          }
          return !0;
        };
      }
      return function (e) {
        try {
          zr.apply(e);
        } catch (t) {
          return !1;
        }
        return !0;
      };
    })(),
    Jr = Number.prototype.valueOf,
    Vr = (function () {
      if (B.bind) {
        var e = B.bind(Jr);
        return function (t) {
          try {
            e(t);
          } catch (n) {
            return !1;
          }
          return !0;
        };
      }
      return function (e) {
        try {
          Jr.apply(e);
        } catch (t) {
          return !1;
        }
        return !0;
      };
    })(),
    Gr = (function () {
      if ('function' == typeof BigInt) {
        var e = B.bind(BigInt.prototype.valueOf);
        return function (t) {
          try {
            e(t);
          } catch (n) {
            return !1;
          }
          return !0;
        };
      }
      return function () {
        return !1;
      };
    })(),
    Xr = BigInt.prototype.valueOf,
    Qr = (function () {
      if (B.bind) {
        var e = B.bind(Xr);
        return function (t) {
          try {
            e(t);
          } catch (n) {
            return !1;
          }
          return !0;
        };
      }
      return function (e) {
        try {
          Xr.apply(e);
        } catch (t) {
          return !1;
        }
        return !0;
      };
    })(),
    es = fe({
      ...pe(
        [...M(32)].map((e, t) => [S(t), '\\u' + t.toString(16).toUpperCase().padStart(4, '0')]),
      ),
      '\b': '\\b',
      '\t': '\\t',
      '\n': '\\n',
      '\f': '\\f',
      '\r': '\\r',
      '"': '\\"',
      '"""': '""\\"',
      '\\': '\\\\',
      '': '\\u007F',
    }),
    { test: ts } = K(/[\x00-\x08\x0A-\x1F'\x7F]/),
    ns = /[^\x00-\x08\x0A-\x1F"\\\x7F]+|./gs,
    { test: is } = K(/^[\x00-\x08\x0A-\x1F"\\\x7F]/),
    rs = e => {
      if (ts(e)) {
        const t = e.match(ns);
        let n = t.length;
        do {
          is(t[--n]) && (t[n] = es[t[n]]);
        } while (n);
        return `"${t.join('')}"`;
      }
      return `'${e}'`;
    },
    { test: ss } = K(/[\x00-\x08\x0A-\x1F\x7F]|'''/),
    { test: as } = K(/[\x00-\x08\x0B-\x1F\x7F]|'''/),
    { test: ls } = K(/[\x00-\x08\x0A-\x1F\\\x7F]|"""/),
    os = /[^\x00-\x08\x0A-\x1F"\\\x7F]+|"""|./gs,
    { test: cs } = K(/^(?:[\x00-\x08\x0A-\x1F\\\x7F]|""")/),
    us = (e, t) => {
      const n = e[t];
      if (ls(n)) {
        const i = n.match(os);
        let r = i.length;
        do {
          cs(i[--r]) && (i[r] = es[i[r]]);
        } while (r);
        e[t] = i.join('');
      }
    },
    fs = e => (1 === (e = ['', ...e]).length ? ['', ''] : e),
    hs = e => {
      let t = e.length - 1;
      for (us(e, t), e[t] += e[0] = '"""'; --t; ) us(e, t);
      return e;
    },
    ds = e => ((e[e.length - 1] += e[0] = "'''"), e),
    ps = Float64Array,
    gs = Uint8Array,
    bs = -1 / 0,
    { test: ys } = K(/^-?\d+$/),
    ws = e => (ys(e) ? e + '.0' : e),
    ms = new ps([NaN]),
    xs = new gs(ms.buffer),
    Ts = xs[7],
    vs =
      Ts === new gs(new ps([NaN]).buffer)[7]
        ? e =>
            e
              ? e === k
                ? 'inf'
                : e === bs
                ? '-inf'
                : ws('' + e)
              : e == e
              ? he(e, 0)
                ? '0.0'
                : '-0.0'
              : 'nan'
        : e =>
            e
              ? e === k
                ? 'inf'
                : e === bs
                ? '-inf'
                : ws('' + e)
              : e == e
              ? he(e, 0)
                ? '0.0'
                : '-0.0'
              : ((ms[0] = e), xs[7] === Ts ? 'nan' : '-nan'),
    Os = p.bind(Hr),
    { test: $s } = K(/^[\w-]+$/),
    Fs = e => ($s(e) ? e : rs(e)),
    Is = /[^.]+/,
    ks = e => `'${e}'`,
    Ss = e => (Gt(e) ? e.replace(Is, ks) : 'null' === e ? "'null'" : e);
  class Ms extends M {
    document;
    constructor(e) {
      return super(), (this.document = e), this;
    }
    [zn.toPrimitive]() {
      return this.join(this.document.newline);
    }
    appendNewline() {
      this[this.length] = '';
    }
    set appendLine(e) {
      this[this.length] = e;
    }
    set appendInline(e) {
      this[this.length - 1] += e;
    }
    set appendInlineIf(e) {
      e && (this[this.length - 1] += e);
    }
    *assignBlock(e, t, i, r) {
      const { document: s } = this,
        { newlineUnderHeader: a, newlineUnderSectionButPair: l } = s,
        o = !!t && s.newlineUnderPairButDotted,
        c = t ? s.newlineUnderDotted : s.newlineUnderPair;
      for (const u of r) {
        const r = i[u],
          f = Fs(u),
          d = e + f;
        if (I(r)) {
          const { length: e } = r;
          if (e) {
            let t = r[0];
            if (_e(t)) {
              const i = `[[${d}]]`,
                o = d + '.';
              let c = 0,
                u = t;
              for (;;) {
                const t = s.appendSection();
                if (
                  ((t[0] = i + Dr(u, Br)),
                  a
                    ? ((t[1] = ''),
                      yield t.assignBlock(o, '', u, h(u)),
                      l && 2 !== t.length && t.appendNewline())
                    : (yield t.assignBlock(o, '', u, h(u)), l && t.appendNewline()),
                  ++c === e)
                )
                  break;
                if (((u = r[c]), !_e(u)))
                  throw n(
                    'the first table item marked by Section() means the parent array is an array of tables, which can not include other types or table not marked by Section() any more in the rest items',
                  );
              }
              continue;
            }
            {
              let t = 1;
              for (; t !== e; )
                if (_e(r[t++]))
                  throw n(
                    'if an array is not array of tables, it can not include any table that marked by Section()',
                  );
            }
          }
        } else if (_e(r)) {
          const e = s.appendSection();
          (e[0] = `[${d}]${
            s.preferCommentForThis ? Dr(r, Br) || jr(i, u) : jr(i, u) || Dr(r, Br)
          }`),
            a
              ? ((e[1] = ''),
                yield e.assignBlock(d + '.', '', r, h(r)),
                l && 2 !== e.length && e.appendNewline())
              : (yield e.assignBlock(d + '.', '', r, h(r)), l && e.appendNewline());
          continue;
        }
        const p = t + f;
        this.appendLine = Ss(p) + ' = ';
        const g = this.value('', r, !0);
        g
          ? (--this.length,
            yield this.assignBlock(d + '.', p + '.', r, g),
            o && this.appendNewline())
          : ((this.appendInlineIf = jr(i, u)), c && this.appendNewline());
      }
    }
    value(e, t, i) {
      switch (typeof t) {
        case 'object':
          if (null === t) {
            if (this.document.nullDisabled)
              throw n('toml can not stringify "null" type value without truthy options.xNull');
            this.appendInline = 'null';
            break;
          }
          const s = De(t);
          if (I(t)) {
            if (s === r) this.staticArray(e, t);
            else {
              const { $singlelineArray: n = s } = this.document;
              this.singlelineArray(e, t, n);
            }
            break;
          }
          if (s !== r) {
            s || this.document.multilineTableDisabled
              ? this.inlineTable(e, t)
              : this.multilineTable(e, t, this.document.multilineTableComma);
            break;
          }
          if (Os(t)) {
            this.appendInline = t
              .toISOString()
              .replace('T', this.document.T)
              .replace('Z', this.document.Z);
            break;
          }
          if (Vn in t) {
            const e = t[Vn];
            if ('string' == typeof e) this.appendInline = e;
            else {
              if (!I(e)) throw n('literal value is broken');
              {
                const { length: t } = e;
                if (!t) throw n('literal value is broken');
                {
                  this.appendInline = e[0];
                  let n = 1;
                  for (; n !== t; ) this.appendLine = e[n++];
                }
              }
            }
            break;
          }
          if (Yr(t)) throw n('TOML.stringify refuse to handle [object String]');
          if (Vr(t)) throw n('TOML.stringify refuse to handle [object Number]');
          if (Gr(t)) throw n('TOML.stringify refuse to handle [object BigInt]');
          if (Qr(t)) throw n('TOML.stringify refuse to handle [object Boolean]');
          if (i) {
            const e = h(t);
            if (e.length) return e;
            this.appendInline = '{ }';
          } else this.inlineTable(e, t);
          break;
        case 'bigint':
          this.appendInline = '' + t;
          break;
        case 'number':
          this.appendInline = this.document.asInteger(t) ? (he(t, -0) ? '-0' : '' + t) : vs(t);
          break;
        case 'string':
          this.appendInline = rs(t);
          break;
        case 'boolean':
          this.appendInline = t ? 'true' : 'false';
          break;
        default:
          throw n(`toml can not stringify "${typeof t}" type value`);
      }
      return null;
    }
    singlelineArray(e, t, n) {
      const { length: i } = t;
      if (i) {
        (this.appendInline = 2 & n ? '[ ' : '['), this.value(e, t[0], !1);
        let r = 1;
        for (; r !== i; ) (this.appendInline = ', '), this.value(e, t[r++], !1);
        this.appendInline = 2 & n ? ' ]' : ']';
      } else this.appendInline = 1 & n ? '[ ]' : '[]';
    }
    staticArray(e, t) {
      this.appendInline = '[';
      const n = e + this.document.indent,
        { length: i } = t;
      let r = 0;
      for (; r !== i; ) (this.appendLine = n), this.value(n, t[r++], !1), (this.appendInline = ',');
      this.appendLine = e + ']';
    }
    inlineTable(e, t) {
      const n = h(t);
      n.length
        ? ((this.appendInline = '{ '),
          this.assignInline(e, t, '', n),
          (this[this.length - 1] = this[this.length - 1].slice(0, -2) + ' }'))
        : (this.appendInline = '{ }');
    }
    multilineTable(e, t, n) {
      (this.appendInline = '{'),
        this.assignMultiline(e, t, '', h(t), n),
        (this.appendLine = e + '}');
    }
    assignInline(e, t, n, i) {
      for (const r of i) {
        const i = t[r],
          s = n + Fs(r),
          a = (this.appendInline = Ss(s) + ' = '),
          l = this.value(e, i, !0);
        l
          ? ((this[this.length - 1] = this[this.length - 1].slice(0, -a.length)),
            this.assignInline(e, i, s + '.', l))
          : (this.appendInline = ', ');
      }
    }
    assignMultiline(e, t, n, i, r) {
      const s = e + this.document.indent;
      for (const a of i) {
        const i = t[a],
          l = n + Fs(a);
        this.appendLine = s + Ss(l) + ' = ';
        const o = this.value(s, i, !0);
        o
          ? (--this.length, this.assignMultiline(e, i, l + '.', o, r))
          : r
          ? (this.appendInline = ',' + jr(t, a))
          : (this.appendInlineIf = jr(t, a));
      }
    }
  }
  const Ls = fe({ document: 0, section: 1, header: 2, pairs: 3, pair: 4 }),
    { test: As } = K(/^[\t ]*$/),
    Bs = () => !1;
  class Us extends M {
    get ['constructor']() {
      return M;
    }
    0 = new Ms(this);
    asInteger = Bs;
    newline = '';
    newlineUnderSection = !0;
    newlineUnderSectionButPair = !0;
    newlineUnderHeader = !0;
    newlineUnderPair = !1;
    newlineUnderPairButDotted = !1;
    newlineUnderDotted = !1;
    indent = '\t';
    T = 'T';
    Z = 'Z';
    nullDisabled = !0;
    multilineTableDisabled = !0;
    multilineTableComma;
    preferCommentForThis = !1;
    $singlelineArray;
    constructor(i) {
      if ((super(), null == i)) return this;
      const { integer: r } = i;
      if (void 0 === r);
      else if (r === qr) this.asInteger = f;
      else {
        if ('number' != typeof r) throw n('TOML.stringify(,{integer}) can only be number');
        {
          if (!f(r)) throw t('TOML.stringify(,{integer}) can only be a safe integer');
          const e = r >= 0 ? r : -r - 1,
            n = r >= 0 ? -r : r;
          this.asInteger = t => f(t) && n <= t && t <= e;
        }
      }
      const { newline: s } = i;
      if (void 0 === s);
      else {
        if ('\n' !== s && '\r\n' !== s)
          throw 'string' == typeof s
            ? e('TOML.stringify(,{newline}) can only be valid TOML newline')
            : n('TOML.stringify(,{newline}) can only be string');
        this.newline = s;
      }
      const { preferCommentFor: a } = i;
      if (void 0 === a);
      else {
        if ('this' !== a && 'key' !== a)
          throw n("TOML.stringify(,{preferCommentFor) can only be 'key' or 'this'");
        this.preferCommentForThis = 'this' === a;
      }
      const { [i.newlineAround || 'header']: l = Ls.header } = Ls;
      (this.newlineUnderSection = l > 0),
        (this.newlineUnderSectionButPair = 1 === l || 2 === l),
        (this.newlineUnderHeader = l > 1),
        (this.newlineUnderPair = l > 2),
        (this.newlineUnderPairButDotted = 3 === l),
        (this.newlineUnderDotted = l > 3);
      const { indent: o } = i;
      if (void 0 === o);
      else if ('string' == typeof o) {
        if (!As(o)) throw e('TOML.stringify(,{indent}) can only include Tab or Space');
        this.indent = o;
      } else {
        if ('number' != typeof o)
          throw n(`TOML.stringify(,{indent}) can not be "${typeof o}" type`);
        if (!f(o)) throw t(`TOML.stringify(,{indent:${o}}) is out of range`);
        this.indent = ' '.repeat(o);
      }
      const { T: c } = i;
      if (void 0 === c);
      else {
        if (' ' !== c && 't' !== c && 'T' !== c)
          throw n('TOML.stringify(,{T}) can only be "T" or " " or "t"');
        this.T = c;
      }
      const { Z: u } = i;
      if (void 0 === u);
      else {
        if ('z' !== u && 'Z' !== u) throw n('TOML.stringify(,{Z}) can only be "Z" or "z"');
        this.Z = u;
      }
      i.xNull && (this.nullDisabled = !1);
      const { xBeforeNewlineInMultilineTable: h } = i;
      if (void 0 === h);
      else {
        if ('' !== h && ',' !== h)
          throw n('TOML.stringify(,{xBeforeNewlineInMultilineTable}) can only be "" or ","');
        (this.multilineTableDisabled = !1), (this.multilineTableComma = !!h);
      }
      const d = i.forceInlineArraySpacing;
      switch (d) {
        case void 0:
          break;
        case 0:
        case 1:
        case 2:
        case 3:
          this.$singlelineArray = d;
          break;
        default:
          throw 'number' == typeof d
            ? t(`array inline mode must be 0 | 1 | 2 | 3, not including ${d}`)
            : n(
                'array inline mode must be "number" type, not including ' +
                  (null === d ? '"null"' : typeof d),
              );
      }
      return this;
    }
    appendSection() {
      return (this[this.length] = new Ms(this));
    }
  }
  const Ds = new se(),
    js = le.bind(Ds),
    Cs = ae.bind(Ds),
    _s = (() => {
      const e = (e, t) =>
        'string' == typeof e
          ? Gn((as(e) ? hs : ds)(('\n' + e).split('\n')), e)
          : I(e)
          ? Gn(
              (e => {
                const t = e.length - 1;
                let n = t;
                do {
                  if (ss(e[n])) break;
                } while (--n);
                if (n) for (n = t, us(e, n), e[n] += e[0] = '"""'; --n; ) us(e, n);
                else e[t] += e[0] = "'''";
                return e;
              })(fs(e)),
              'string' == typeof t ? t : fe(null),
            )
          : (e => (je(e, !1), Be(e), e))(e);
      return (
        (e.basic = (e, t) =>
          'string' == typeof e
            ? Gn(hs(('\n' + e).split('\n')), e)
            : Gn(hs(fs(e)), 'string' == typeof t ? t : fe(null))),
        (e.array = Ce),
        d(e),
        e
      );
    })(),
    Ns = new Hn('utf-8', fe({ fatal: !0, ignoreBOM: !1 })),
    Es = e => {
      if (Zn(e) ? e.length !== e.byteLength : !qn(e))
        throw n('only Uint8Array or ArrayBuffer is acceptable');
      try {
        return Ns.decode(e);
      } catch {
        throw i(
          'A TOML doc must be a (ful-scalar) valid UTF-8 file, without any unknown code point.',
        );
      }
    },
    Ps = e => 'byteLength' in e,
    { test: Ks } = K(/[\uD800-\uDFFF]/u),
    Ws = e => {
      if (G(Ks(e)))
        throw i(
          'A TOML doc must be a (ful-scalar) valid UTF-8 file, without any uncoupled UCS-4 character code.',
        );
    };
  let Rs = !1;
  const Zs = (e, a, l, o, c, u) => {
    let d,
      p,
      g,
      b,
      y = '';
    if ('object' == typeof e && e) {
      if (I(e))
        throw n(Cs(e) ? 'TOML.parse(array from TOML.stringify(,{newline?}))' : 'TOML.parse(array)');
      if (Ps(e)) e = Es(e);
      else {
        if (((y = e.path), 'string' != typeof y)) throw n('TOML.parse(source.path)');
        const { data: t, require: i = 'function' == typeof require ? require : r } = e;
        if (i) {
          const { resolve: s } = i;
          if (null != s) {
            const { paths: e } = s;
            if (null != e) {
              const t = m(e, s, ['']);
              if (null != t) {
                const e = t[0];
                if (null != e) {
                  const t = e.replace(/node_modules$/, '');
                  if (t && ((y = i('path').resolve(t, y)), 'string' != typeof y))
                    throw n("TOML.parse(source.require('path').resolve)");
                }
              }
            }
          }
          if (t === r) {
            const t = i('fs').readFileSync(y);
            if ('object' != typeof t || !t || !Ps(t))
              throw n("TOML.parse(source.require('fs').readFileSync)");
            e = Es(t);
          } else if ('string' == typeof t) Ws((e = t));
          else {
            if ('object' != typeof t || !t || !Ps(t)) throw n('TOML.parse(source.data)');
            e = Es(t);
          }
        } else {
          if (t === r) throw n('TOML.parse(source.data|source.require)');
          if ('string' == typeof t) Ws((e = t));
          else {
            if ('object' != typeof t || !t || !Ps(t)) throw n('TOML.parse(source.data)');
            e = Es(t);
          }
        }
      }
    } else {
      if ('string' != typeof e) throw n('TOML.parse(source)');
      Ws(e);
    }
    if ('object' == typeof l && l) {
      if (o !== r || c !== r) throw n('options mode ? args mode');
      (d = l.joiner), (o = l.bigint), (p = l.keys), (c = l.x), (u = '');
    } else d = l;
    if (Rs) throw i('parsing during parsing.');
    Rs = !0;
    try {
      ((e, a, l, o, c, u) => {
        let d;
        switch (((Qt = u), e)) {
          case 1:
            (Xt = d = fn = pn = un = !0), (cn = hn = !1);
            break;
          case 0.5:
            (Xt = fn = pn = un = !0), (d = cn = hn = !1);
            break;
          case 0.4:
            (Xt = hn = un = !0), (d = cn = fn = pn = !1);
            break;
          case 0.3:
            (Xt = hn = !0), (d = cn = fn = pn = un = !1);
            break;
          case 0.2:
          case 0.1:
            (cn = hn = !0), (Xt = d = fn = pn = un = !1);
            break;
          default:
            throw t('TOML.parse(,specificationVersion)');
        }
        if (
          ((e => {
            switch (e) {
              case 1:
                (gt = dt), (Wt = Pt), (zt = qt), (kt = Ot), (Ut = Mt), (Et = _t), (Rt = !0);
                break;
              case 0.5:
                (gt = pt), (Wt = Pt), (zt = qt), (kt = $t), (Ut = Lt), (Et = _t), (Rt = !0);
                break;
              case 0.4:
                (gt = pt), (Wt = Kt), (zt = Ht), (kt = Ft), (Ut = At), (Et = _t), (Rt = !0);
                break;
              default:
                (gt = pt), (Wt = Kt), (zt = Ht), (kt = It), (Ut = Bt), (Et = Nt), (Rt = !1);
            }
          })(e),
          'string' == typeof a)
        )
          en = a;
        else {
          if (a !== r) throw n(`TOML.parse(${Qt ? `${Qt}multilineStringJoiner` : ',{ joiner }'})`);
          en = null;
        }
        if (l === r || !0 === l) tn = !0;
        else if (!1 === l) tn = !1;
        else {
          if ('number' != typeof l)
            throw n(`TOML.parse(${Qt ? `${Qt},useBigInt` : ',{ bigint }'})`);
          if (!f(l)) throw t(`TOML.parse(${Qt ? `${Qt},useBigInt` : ',{ bigint }'})`);
          (tn = null), l >= 0 ? (nn = -(rn = l)) : (rn = -(nn = l) - 1);
        }
        if (!s && !1 !== tn)
          throw i(
            `Can't work without TOML.parse(${
              Qt ? `${Qt},useBigInt` : ',{ bigint }'
            }) being set to false, because the host doesn't have BigInt support`,
          );
        if (null == o) Tn = sn;
        else {
          if (!ln(o)) throw n('TOML.parse(,{ keys })');
          Tn = o;
        }
        if (null == c) (gn = Ve), (dn = bn = yn = wn = !1), (Rn = Wn);
        else {
          if ('object' != typeof c) throw n(`TOML.parse(${Qt ? `${Qt},,xOptions` : ',{ x }'})`);
          {
            const {
                order: e,
                longer: t,
                exact: i,
                null: r,
                multi: s,
                comment: a,
                string: l,
                literal: o,
                tag: u,
                ...f
              } = c,
              p = h(f);
            if (p.length)
              throw n(
                `TOML.parse(${Qt ? `${Qt},,{ ${p.join(', ')} }` : `,{ x: { ${p.join(', ')} } }`})`,
              );
            if (
              ((gn = e ? Ge : Ve),
              (bn = !t),
              (dn = !!i),
              (yn = !!r),
              (wn = !!s),
              (mn = !!a),
              (xn = !!l),
              (on = !!o),
              u)
            ) {
              if ('function' != typeof u)
                throw n(`TOML.parse(${Qt ? `${Qt},,{ tag }` : ',{ x: { tag } }'})`);
              if (!d)
                throw n(
                  `TOML.parse(${
                    Qt ? `${Qt},,xOptions` : ',{ x }'
                  }) xOptions.tag needs at least TOML 1.0 to support mixed type array`,
                );
              (En = u), (Rn = Kn);
            } else Rn = Wn;
          }
        }
        d
          ? (Sn = Mn = Ln = An = Bn = Un = Dn = jn = Cn = _n = Nn = kn)
          : ({
              asNulls: Sn,
              asStrings: Mn,
              asTables: Ln,
              asArrays: An,
              asBooleans: Bn,
              asFloats: Un,
              asIntegers: Dn,
              asOffsetDateTimes: jn,
              asLocalDateTimes: Cn,
              asLocalDates: _n,
              asLocalTimes: Nn,
            } = In);
      })(a, d, o, p, c, u),
        st(e, y),
        e &&
          '\ufeff' === e[0] &&
          it(n('TOML content (string) should not start with BOM (U+FEFF)' + lt(' at '))),
        (g = Zr()),
        (b = (() => {
          if (Pn) {
            const e = En;
            let t = Pn;
            return (
              (Pn = null),
              () => {
                const n = e;
                let i = t;
                t = null;
                do {
                  n(i);
                } while ((i = i._linked));
              }
            );
          }
          return null;
        })());
    } finally {
      ot(), (Tn = sn), (en = En = Pn = null), (cn = !1), (Rs = !1), G();
    }
    return b && b(), g;
  };
  return _({
    version: '1.36.0',
    parse: O(
      (e, t, n, i, r) => ('number' == typeof t ? Zs(e, t, n, i, r, ',,') : Zs(e, 1, t, n, i, ',')),
      {
        '1.0': (e, t, n, i) => Zs(e, 0.1, t, n, i, ','),
        1: (e, t, n, i) => Zs(e, 1, t, n, i, ','),
        0.5: (e, t, n, i) => Zs(e, 0.5, t, n, i, ','),
        0.4: (e, t, n, i) => Zs(e, 0.4, t, n, i, ','),
        0.3: (e, t, n, i) => Zs(e, 0.3, t, n, i, ','),
        0.2: (e, t, n, i) => Zs(e, 0.2, t, n, i, ','),
        0.1: (e, t, n, i) => Zs(e, 0.1, t, n, i, ','),
      },
    ),
    stringify: (e, t) => {
      const n = new Us(t),
        i = n[0];
      if (
        ((i[0] = ''),
        Jn(i.assignBlock('', '', e, h(e))),
        n.newlineUnderSectionButPair && 1 !== i.length && i.appendNewline(),
        n.newlineUnderSection || n[n.length - 1].appendNewline(),
        n.newline)
      )
        return n.join(n.newline);
      const r = n.flat();
      return js(r), r;
    },
    Section: e => {
      if (I(e)) throw n('array can not be section, maybe you want to use it on the tables in it');
      return Ne(e), Ae(e), e;
    },
    inline: (e, i, s) => {
      if (I(e)) {
        if (s) i = 3;
        else if (i === r) i = 3;
        else if (0 !== i && 1 !== i && 2 !== i && 3 !== i)
          throw 'number' == typeof i
            ? t(`array inline mode must be 0 | 1 | 2 | 3, not including ${i}`)
            : n(
                'array inline mode must be "number" type, not including ' +
                  (null === i ? '"null"' : typeof i),
              );
        je(e, i);
      } else je(e, !0), Be(e);
      return e;
    },
    multiline: _s,
    basic: e =>
      Gn(
        (e => {
          if (e) {
            const t = e.match(ns);
            let n = t.length;
            do {
              is(t[--n]) && (t[n] = es[t[n]]);
            } while (n);
            return `"${t.join('')}"`;
          }
          return '""';
        })(e),
        e,
      ),
    literal: (e, ...t) => {
      if ('string' == typeof e) {
        if (1 === t.length) return Gn(e.includes('\n') ? e.split('\n') : e, t[0]);
      } else {
        let n = t.length;
        if (n) {
          const { raw: i } = e;
          for (e = i[n]; n; ) t[--n] += i[n];
          e = t.join('') + e;
        } else e = e.raw[0];
      }
      return Gn(e.includes('\n') ? e.split('\n') : e, fe(null));
    },
    commentFor: Ar,
    commentForThis: Br,
    OffsetDateTime: Ni,
    LocalDateTime: Ri,
    LocalDate: Yi,
    LocalTime: Qi,
    isInline: Ue,
    isSection: _e,
    Keys: an,
  });
});
//# sourceMappingURL=j-toml.min.js.map
